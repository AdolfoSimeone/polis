{{> top}}
{{> header}}

<script>
function switchLanguages() {
    if (window.location.hash && window.location.hash.length) {
        var lang = window.location.hash.slice(1);
        $(".code_sample").hide();
        $(".code_" + lang).show();
        $(".pill").removeClass("active");
        $(".pill_" + lang).addClass("active");
    }
}
$(window).on('hashchange', switchLanguages);
$(document).ready(switchLanguages);
</script>

<div class="container">
  <div class="row" style="margin-top: 20px;">
    <div class="col-sm-12">
      <h1 class="HeadingA"> API </h1>
      <!-- groups are very powerful... sentiment groups... correlations... we'll give you... recurring... programmatic... --> 
      <ul class="nav nav-pills col-sm-6">
          <li class="pill pill_curl active"><a href="#curl">Curl</a></li>
          <li class="pill pill_ruby"><a href="#ruby">Ruby</a></li>
      </ul>
    </div>
  </div>
  


{{!-- 
        POST CONVERSATIONS
 --}}
  <div id="createConversation" class="row">
  <div class="col-sm-12">
    <h3 ><a href="#createConversation"># Creating a conversation</a></h3>  
  </div>

  <div class="col-sm-5">
    <h5>API</h5>
    <p> The API key is the only required field. A minimal request...</p> 
<pre> <code data-language="shell">curl -s "pol.is/api/v3/create" \
  -X POST \
  -u app-id:api-key \</code></pre> 
  <p>...will create a conversation that is immediately accessible on the internet at the returned url. It will have the following defaults:  </p>
<pre><code data-language="javascript">short_url: true //false: long link
topic: ""
description: ""
</code></pre>
    <p> By default, conversations are easily typeable shortlinks that anyone on the internet can access: <pre> <code data-language="javascript"> pol.is/b2xpm7w </code> </pre> 
    <p>Obviously, some conversations are more sensitive and require security. There are two tiers: </p>
    <h5> LONG LINKS </h5> <p> Assumes your users can be trusted not to share a single link to the conversation. This is similar to YouTube & Google Docs, which use very long strings of letters and numbers to ensure that no one without the link can find the location of the document or the video on the internet. Good for internal business communication - easy to share, low overhead, secure enough.</p>

<pre><code data-language="javascript">short_url: false 
</code></pre>

    <h5> SINGLE USE URLs </h5> <p> Assumes that users will not be trusted to keep a link secret - renders each link useless once it is used. See <a href="#addingUsers">Creating single use URLs</a>.</p>

    <div class="alert alert-warning">
      <p><p><strong> Heads up! </strong> </p> <p style="display: inline"> Even if you plan on generating single-use urls, we still return a reusable url from this call: the response to create a conversation <em> always </em> returns a valid url. Passing</p> <code>short_url: false</code> <p style="display:inline"> makes this more secure.</p> <p>An example of when you might want this? Ask a bunch of customers a question by sending them single use urls, then use the long link to share the results with your coworkers internally. </p>
    </div>

  </div>
  <div class="col-sm-7">

<h5> REQUEST </h5>
<pre>
<code class="code_sample code_curl" data-language="shell">curl -X POST -s "https://pol.is/v3/conversations" \
      --user $POLIS_API_KEY: \
      -F topic="Should we raise the minimum wage?" \
      -F description="It's currently under $10/hr, What do you think?" \
      -F is_public=true \
      -F strict_moderation=false 
</code>
<code class="code_sample code_ruby" style="display:none;" data-language="ruby"> #NOTE this expects that you have done something like 'export POLIS_API_KEY=your_polis_api_key' in your environment before starting your ruby process. We recommend you avoid putting your API key directly in your source code.
require 'net/http'
require 'uri'
require 'json'

uri = URI.parse('https://pol.is/v3/conversations')

http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = true

request = Net::HTTP::Post.new(uri.path, {
    'Content-Type' =>'application/json'
})
request.basic_auth ENV['POLIS_API_KEY'], ''

data = {
    'topic' => "Should we raise the minimum wage?",
    'description' => "It's currently under $10/hr, What do you think?",
    'is_public' => false,
    'strict_moderation' => false,
}

request.body = data.to_json
response = http.request(request)

puts response.body
</code>
</pre>
  <h5>RESPONSE</h5>
<pre> <code data-language="javascript">{
  conversation_id: "1234abc",
  url: "pol.is/1234abc",
}
</code></pre>

  </div> <!--column-->
</div> <!--row-->



{{!-- 
        METADATA QUESTIONS
 --}}
{{!-- <div id="getUsersPerLabel"class="row">
  <div class="col-sm-12">
    <h3 name="getLabels" style="border-bottom: 1px solid lightgrey"><a href="#getUsersPerLabel"># Adding custom metadata</a></h3>  
  </div>

  <div class="col-sm-5">
    <h5>API</h5>
    <p>Send Polis metadata that will show up in the GUI - look for it in the 'analyze' tab. For use with <a href="#addingUsers">single use URLs</a>. </p>
    <p> Arbitrary metadata you send us is mapped to <code>xids</code>, which are in turn mapped to single use URLs. Array of arrays. Each internal array should contain: <code>[xid, column, value]</code>. If there is a duplicate <code>xid</code> & <code>column</code>, we'll use the most recent <code>value</code> we have, so updates are the same format.</p>
  </div>
  <div class="col-sm-7">
    <h5> REQUEST </h5>
<pre> <code data-language="shell">curl -s "pol.is/api/v3/conversation_id/metadata" \
  -X POST \
  -u app-id:api-key \
  -H "Content-Type: application/json" \
  --data '{
    conversation_id: "1234abc",
    [ ["mnpq678", "city", "seattle" ], ["pkhr345", "city", "seattle"], ["wxkqe95", "pet", "llama"], ["ngk895c", "milliseconds_to_conversion", "lickitysplit"], ...]
  }'  
</code></pre>
  <h5>RESPONSE</h5>
<pre> <code data-language="javascript">{
  status: "success" //status: "failure"
}
</code></pre>
  </div> <!--column-->
</div> <!--row--> --}}



{{!-- 
        SINGLE USE URLS suurls
 --}}
{{!-- <div id="addingUsers"class="row">
  <div class="col-sm-12">
    <h3 name="addingUsers" style="border-bottom: 1px solid lightgrey"><a href="#addingUsers"> # Creating single-use URLs</a></h3>  
  </div>

  <div class="col-sm-5">
    <h5>API</h5>
    <p> A single-use 'join' url returned for each <code>xid</code> sent to us in the request. When a user hits this type of url, they enter the conversation immediately (or hit the metadata page immediately) without being asked to login, whether they have an account or not. </p>

    <p> This is a measure to prevent the conversation from spreading to users you have not invited. Once this url has been used, it becomes useless. If the user is logged in when they first hit the url, they will continue to have access to the conversation. </p>   

    <p> This request uses the <code>conversation_id</code> returned by the <a href="#createConversation"> request to create a conversation </a>. Create single use tokens so that users who enter the conversation cannot share their link with anyone else. To do this, you will need to provide us with a list of <code>xids</code> (external ids) that can be anything you want, should made up by you & should map to your users in your database environment. The <code>xids</code> you provide are scoped to your own namespace in our database environment - you are free to use whatever identifier scheme you want (integers, guids, etc). </p>
    <pre><code data-language="javascript">single_use_tokens: true</code></pre>
    <div class="alert alert-warning">
    <p> <p><strong> Heads up! </strong> </p><p style="display:inline">If your user IDs are tied to your business logic (ie., if user ID 23453 means that you have >= 23,453 users in a database table), it may be undesirable to expose them directly. A good option is to map them to magic tokens in a new db table, and associate the</p> <code>xids</code> <p style="display:inline"> you send to us with the tokens.</p> <!-- <a href="tokentutorial.html">See this tutorial on creating magic tokens (unique random numbers).</a> --></p>
    </div>
  </div>
  <div class="col-sm-7">
    <h5> REQUEST </h5>
<pre> <code data-language="shell">curl -s "pol.is/api/v3/generateSingleUseTokens" \
  -X POST \
  -u app-id:api-key \
  -H "Content-Type: application/json" \
  --data '{
    conversation_id: "1234abc",
    xids: ["mnpq678", "pkhr345", "wxkqe945", ...]
  }'  
</code></pre>
  <h5>RESPONSE</h5>
<pre> <code data-language="javascript">{
  invitation_urls: {
    "mnpq678": "pol.is/s1ng13us3m4g1ct0k3n1",
    "pkhr345": "pol.is/4n0th3rm4g1ct0ken234",
    "wxkqe945": "pol.is/0n3m0r3m4g1ct0k3n567",
    ...
  }
}
</code></pre>
  </div> <!--column-->
</div> <!--row--> --}}


{{!-- 
        GET COHORTS
 --}}
{{!-- <div id="getLabels"class="row">
  <div class="col-sm-12">
    <h3 name="getLabels" style="border-bottom: 1px solid lightgrey"><a href="#getLabels"># Getting a list of cohorts created in the Polis GUI</a></h3>  
  </div>

  <div class="col-sm-5">
    <h5>API</h5>
    <p>If you created cohorts in the Polis GUI, you can grab the data here. Returns an object where the keys are strings of cohorts you created, and the values are arrays of <code>xids</code> you can map back to your users in your database environment.</p>
  </div>
  <div class="col-sm-7">
    <h5> REQUEST </h5>
<pre> <code data-language="javascript">curl -s "pol.is/api/v3/conversation_id/cohorts" \
  -X GET \
  -u app-id:api-key
</code></pre>
  <h5>RESPONSE</h5>
<pre><code data-language="javascript">{
  cohorts: {
    "happy people": ["user1", "user2", "user3" ...],
    "needs not being met": ["user8", "user16", "user32" ...]
  }
}
</code></pre>
  </div> <!--column-->
</div> <!--row--> --}}

</div> <!--container-->

{{> footer}}
